# https://github.com/BorjaRequena/Quantum-Fisherman/blob/830612ae01079054ccc48589b8b4b9cdfa407be5/fisherman/overlap/randomized.py
# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_overlap.randomized.ipynb (unless otherwise specified).

__all__ = ['random_unitary_circuits', 'randomized_measurement_overlap', 'device_independent_overlap']

# Cell
import numpy as np
from ..utils import sym_from_triu, statevector_basis, hamming_distance

from qiskit import QuantumCircuit
from qiskit.providers import Backend
from qiskit.utils import QuantumInstance
from qiskit.quantum_info import random_unitary
from qiskit.circuit import ParameterExpression
from qiskit.opflow import ListOp, StateFn, PrimitiveOp, TensoredOp, ExpectationBase, CircuitSampler, Zero

from collections.abc import Iterable
from typing import Optional, Union, Dict, List

# Cell
def random_unitary_circuits(
    n_rnd: int,
    n_qubits: int,
    d: Optional[int] = 2,
    local: bool = True
) -> ListOp:
    "Samples `n_rnd` unitary random circuits with acting on `n_qubits`."
    def _random_circuit(n_qubits):
        if local:
            return TensoredOp([PrimitiveOp(random_unitary(d)) for _ in range(n_qubits)])
        else:
            return PrimitiveOp(random_unitary(d**n_qubits))
    return ListOp([_random_circuit(n_qubits) for _ in range(n_rnd)])

# Cell
def randomized_measurement_overlap(
    state0: Union[StateFn, QuantumCircuit],
    state1: Optional[Union[StateFn, ListOp]] = None,
    param_dict: Optional[Dict[ParameterExpression, List[float]]] = None,
    n_rnd: Optional[int] = None,
    local: bool = True,
    expectation: Optional[ExpectationBase] = None,
    backend: Optional[Union[Backend, QuantumInstance]] = None
) -> np.ndarray:
    """Overlap computation between states using randomized measurements."""

    if state1 is not None and param_dict is not None:
        raise ValueError(
            "randomized_measurement_overlap only accepts one optional input "
            "either `state1` or `param_dict`."
        )

    if isinstance(state0, QuantumCircuit):
        state0 = CircuitStateFn(state0)

    if param_dict is not None:
        state = state0.bind_parameters(param_dict)
    elif state1 is not None:
        state = ListOp([state0, *state1]) if isinstance(state1, ListOp) else ListOp([state0, state1])
    else:
        state = ListOp([state0])

    n_qubits = state0.num_qubits
    n_rnd = 2**(6 + n_qubits//2) if n_rnd is None else n_rnd
    U = random_unitary_circuits(n_rnd, n_qubits, local=local)
    observable = (U @ state) if local else (~Zero @ U @ state)

    if expectation is not None:
        observable = expectation.convert(observable)

    if backend is not None:
        observable = CircuitSampler(backend).convert(observable)

    overlap = _overlap_from_local(observable) if local else _overlap_from_global(observable)

    return overlap[0, 1:].squeeze() if state1 is not None else overlap.squeeze()

def _overlap_from_global(
    observable: StateFn
) -> np.ndarray:
    "Overlap computation from measurements obtained through global random unitaries."
    rnd_meas = np.abs(observable.eval())**2
    p = rnd_meas.mean(0)

    def _prefactor(counts):
        "Prefactor `N(N+1)` where `N` is the estimated Hilbert space size."
        n_experiments = counts.shape[1]
        pmat = np.broadcast_to(p, (n_experiments, n_experiments))
        N = 1/pmat # Estimated size of the Hilbert space
        triu = np.triu(np.ones(n_experiments))
        tril = np.where(triu==0, 1, 0)
        return (N + triu)*(N.T + tril)

    product_expectation = (rnd_meas.T @ rnd_meas)/rnd_meas.shape[0]
    return _prefactor(rnd_meas)*product_expectation - 1

def _overlap_from_local(
    observable: StateFn,
    transp_sv: bool = True
) -> np.ndarray:
    "Overlap computation from measurements obtained through local random unitaries."
    statevectors = _statevector_to_matrix(observable.eval())
    if transp_sv:
        statevectors = statevectors.transpose(1, 0, 2)
    rnd_meas = np.abs(statevectors)**2
    n_states, n_rnd, _ = rnd_meas.shape

    def _prefactor(n, d=2):
        "Prefacotr ::math:: $(-d)^{-D(s, s')}$. See Eq. (4) in [ref]"
        v = statevector_basis(n)
        dists = sym_from_triu([hamming_distance(v_i, v_j)
                               for i, v_i in enumerate(v) for v_j in v[i:]], d**n)
        return (-d)**(-dists)

    pref = _prefactor(observable.num_qubits)
    N = 1/rnd_meas.mean()
    overlaps = [np.sum(N*pref*(m_i.T @ m_j)/n_rnd)
                for i, m_i in enumerate(rnd_meas) for m_j in rnd_meas[i:]]
    return sym_from_triu(overlaps, n_states)

def _statevector_to_matrix(v):
    list_of_matrices = list(map(lambda x: list(map(lambda y: y.to_matrix().squeeze(), x)), v))
    return np.array(list_of_matrices)

# Cell
def device_independent_overlap(
    state0: StateFn,
    backends: Union[QuantumInstance, Backend, Iterable[Union[QuantumInstance, Backend]]],
    state1: Optional[Union[StateFn, ListOp, List[StateFn]]] = None,
    n_rnd: Optional[int] = None,
    local: bool = True
) -> np.ndarray:
    "Computes overlap between states through randomized measurements using different backends."

    n_qubits = state0.num_qubits
    n_rnd = 2**(6 + n_qubits//2) if n_rnd is None else n_rnd
    U = random_unitary_circuits(n_rnd, n_qubits, local=local)

    if not isinstance(backends, Iterable):
        backends = [backends]
    n_backends = len(backends)

    if state1 is None:
        if n_backends > 1:
            states = [state0]*len(backends)
        else:
            raise ValueError(
                "If `state1` is not provided, the number of backeds must be larger"
                f" than one, not {len(backends)}."
            )
    else:
        if not isinstance(state1, Iterable):
            state1 = [state1]
        states = [state0, *state1]
        if n_backends == 1:
            from qiskit.providers.aer import StatevectorSimulator
            backends = [StatevectorSimulator()] + backends*len(state1)
        elif n_backends == 2:
            backends = [backends[0]] + [backends[1]]*len(state1)
        elif n_backends == len(state1):
            from qiskit.providers.aer import StatevectorSimulator
            backends = [StatevectorSimulator()] + backends
        elif n_backends == len(states):
            pass
        else:
            raise ValueError(
                f"Number of backends must be either 1, 2, len(state1) = {len(state1)} "
                f"or len(state1) + 1 = {len(state1) + 1}, not {n_backends}."
            )

    observable = ListOp([CircuitSampler(qi).convert((U @ s) if local else (~Zero @ U @ s))
                  for qi, s in zip(backends, states)])

    overlap = (_overlap_from_local(observable, transp_sv=False) if local
               else _overlap_from_global(observable))

    return overlap

    return overlap[0] if state1 is not None else overlap.squeeze()